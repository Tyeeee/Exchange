package com.hynet.heebit.components.widget.tablayout;import android.content.Context;import android.content.res.TypedArray;import android.graphics.Canvas;import android.graphics.Color;import android.graphics.Paint;import android.graphics.RectF;import android.util.AttributeSet;import android.util.TypedValue;import android.view.View;import android.widget.LinearLayout;import com.hynet.heebit.components.R;import com.hynet.heebit.components.utils.ViewUtil;import com.hynet.heebit.components.widget.tablayout.listener.TabColorizer;import com.hynet.heebit.components.widget.tablayout.listener.implement.SimpleTabColorizer;public class TabStrip extends LinearLayout {    private static final int GRAVITY_BOTTOM = 0;    private static final int GRAVITY_TOP = 1;    private static final int GRAVITY_CENTER = 2;    private static final int AUTO_WIDTH = -1;    private static final int DEFAULT_TOP_BORDER_THICKNESS_DIPS = 0;    private static final byte DEFAULT_TOP_BORDER_COLOR_ALPHA = 0x26;    private static final int DEFAULT_BOTTOM_BORDER_THICKNESS_DIPS = 2;    private static final byte DEFAULT_BOTTOM_BORDER_COLOR_ALPHA = 0x26;    private static final int SELECTED_INDICATOR_THICKNESS_DIPS = 8;    private static final int DEFAULT_SELECTED_INDICATOR_COLOR = 0xFF33B5E5;    private static final float DEFAULT_INDICATOR_CORNER_RADIUS = 0f;    private static final int DEFAULT_DIVIDER_THICKNESS_DIPS = 1;    private static final byte DEFAULT_DIVIDER_COLOR_ALPHA = 0x20;    private static final float DEFAULT_DIVIDER_HEIGHT = 0.5f;    private static final boolean DEFAULT_INDICATOR_IN_CENTER = false;    private static final boolean DEFAULT_INDICATOR_IN_FRONT = false;    private static final boolean DEFAULT_INDICATOR_WITHOUT_PADDING = false;    private static final int DEFAULT_INDICATOR_GRAVITY = GRAVITY_BOTTOM;    private static final boolean DEFAULT_DRAW_DECORATION_AFTER_TAB = false;    private final int topBorderThickness;    private final int topBorderColor;    private final int bottomBorderThickness;    private final int bottomBorderColor;    private final Paint borderPaint;    private final RectF indicatorRectF = new RectF();    private final boolean indicatorWithoutPadding;    private final boolean indicatorAlwaysInCenter;    private final boolean indicatorInFront;    private final int indicatorThickness;    private final int indicatorWidth;    private final int indicatorGravity;    private final float indicatorCornerRadius;    private final Paint indicatorPaint;    private final int dividerThickness;    private final Paint dividerPaint;    private final float dividerHeight;    private final SimpleTabColorizer defaultTabColorizer;    private final boolean drawDecorationAfterTab;    private int lastPosition;    private int selectedPosition;    private float selectionOffset;    private TabIndicationInterpolator tabIndicationInterpolator;    private TabColorizer customTabColorizer;    TabStrip(Context context, AttributeSet attrs) {        super(context);        setWillNotDraw(false);        final float density = getResources().getDisplayMetrics().density;        TypedValue typedValue = new TypedValue();        context.getTheme().resolveAttribute(android.R.attr.colorForeground, typedValue, true);        final int foregroundColor = typedValue.data;        TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.TabLayout);        boolean indicatorAlwaysInCenter = typedArray.getBoolean(R.styleable.TabLayout_tl_indicatorAlwaysInCenter, DEFAULT_INDICATOR_IN_CENTER);        boolean indicatorWithoutPadding = typedArray.getBoolean(R.styleable.TabLayout_tl_indicatorWithoutPadding, DEFAULT_INDICATOR_WITHOUT_PADDING);        boolean indicatorInFront = typedArray.getBoolean(R.styleable.TabLayout_tl_indicatorInFront, DEFAULT_INDICATOR_IN_FRONT);        int indicationInterpolatorId = typedArray.getInt(R.styleable.TabLayout_tl_indicatorInterpolation, TabIndicationInterpolator.ID_SMART);        int indicatorGravity = typedArray.getInt(R.styleable.TabLayout_tl_indicatorGravity, DEFAULT_INDICATOR_GRAVITY);        int indicatorColor = typedArray.getColor(R.styleable.TabLayout_tl_indicatorColor, DEFAULT_SELECTED_INDICATOR_COLOR);        int indicatorColorsId = typedArray.getResourceId(R.styleable.TabLayout_tl_indicatorColors, View.NO_ID);        int indicatorThickness = typedArray.getDimensionPixelSize(R.styleable.TabLayout_tl_indicatorThickness, (int) (SELECTED_INDICATOR_THICKNESS_DIPS * density));        int indicatorWidth = typedArray.getLayoutDimension(R.styleable.TabLayout_tl_indicatorWidth, AUTO_WIDTH);        float indicatorCornerRadius = typedArray.getDimension(R.styleable.TabLayout_tl_indicatorCornerRadius, DEFAULT_INDICATOR_CORNER_RADIUS * density);        int overlineColor = typedArray.getColor(R.styleable.TabLayout_tl_overlineColor, setColorAlpha(foregroundColor, DEFAULT_TOP_BORDER_COLOR_ALPHA));        int overlineThickness = typedArray.getDimensionPixelSize(R.styleable.TabLayout_tl_overlineThickness, (int) (DEFAULT_TOP_BORDER_THICKNESS_DIPS * density));        int underlineColor = typedArray.getColor(R.styleable.TabLayout_tl_underlineColor, setColorAlpha(foregroundColor, DEFAULT_BOTTOM_BORDER_COLOR_ALPHA));        int underlineThickness = typedArray.getDimensionPixelSize(R.styleable.TabLayout_tl_underlineThickness, (int) (DEFAULT_BOTTOM_BORDER_THICKNESS_DIPS * density));        int dividerColor = typedArray.getColor(R.styleable.TabLayout_tl_dividerColor, setColorAlpha(foregroundColor, DEFAULT_DIVIDER_COLOR_ALPHA));        int dividerColorsId = typedArray.getResourceId(R.styleable.TabLayout_tl_dividerColors, View.NO_ID);        int dividerThickness = typedArray.getDimensionPixelSize(R.styleable.TabLayout_tl_dividerThickness, (int) (DEFAULT_DIVIDER_THICKNESS_DIPS * density));        boolean drawDecorationAfterTab = typedArray.getBoolean(R.styleable.TabLayout_tl_drawDecorationAfterTab, DEFAULT_DRAW_DECORATION_AFTER_TAB);        typedArray.recycle();        final int[] indicatorColors = (indicatorColorsId == View.NO_ID) ? new int[]{indicatorColor} : getResources().getIntArray(indicatorColorsId);        final int[] dividerColors = (dividerColorsId == View.NO_ID) ? new int[]{dividerColor} : getResources().getIntArray(dividerColorsId);        this.defaultTabColorizer = new SimpleTabColorizer();        this.defaultTabColorizer.setIndicatorColors(indicatorColors);        this.defaultTabColorizer.setDividerColors(dividerColors);        this.topBorderThickness = overlineThickness;        this.topBorderColor = overlineColor;        this.bottomBorderThickness = underlineThickness;        this.bottomBorderColor = underlineColor;        this.borderPaint = new Paint(Paint.ANTI_ALIAS_FLAG);        this.indicatorAlwaysInCenter = indicatorAlwaysInCenter;        this.indicatorWithoutPadding = indicatorWithoutPadding;        this.indicatorInFront = indicatorInFront;        this.indicatorThickness = indicatorThickness;        this.indicatorWidth = indicatorWidth;        this.indicatorPaint = new Paint(Paint.ANTI_ALIAS_FLAG);        this.indicatorCornerRadius = indicatorCornerRadius;        this.indicatorGravity = indicatorGravity;        this.dividerHeight = DEFAULT_DIVIDER_HEIGHT;        this.dividerPaint = new Paint(Paint.ANTI_ALIAS_FLAG);        this.dividerPaint.setStrokeWidth(dividerThickness);        this.dividerThickness = dividerThickness;        this.drawDecorationAfterTab = drawDecorationAfterTab;        this.tabIndicationInterpolator = TabIndicationInterpolator.of(indicationInterpolatorId);    }    private static int setColorAlpha(int color, byte alpha) {        return Color.argb(alpha, Color.red(color), Color.green(color), Color.blue(color));    }    private static int blendColors(int color1, int color2, float ratio) {        final float inverseRation = 1f - ratio;        float r = (Color.red(color1) * ratio) + (Color.red(color2) * inverseRation);        float g = (Color.green(color1) * ratio) + (Color.green(color2) * inverseRation);        float b = (Color.blue(color1) * ratio) + (Color.blue(color2) * inverseRation);        return Color.rgb((int) r, (int) g, (int) b);    }    void setTabIndicationInterpolator(TabIndicationInterpolator tabIndicationInterpolator) {        this.tabIndicationInterpolator = tabIndicationInterpolator;        invalidate();    }    void setCustomTabColorizer(TabColorizer customTabColorizer) {        this.customTabColorizer = customTabColorizer;        invalidate();    }    void setSelectedIndicatorColors(int... colors) {        // Make sure that the custom colorizer is removed        customTabColorizer = null;        defaultTabColorizer.setIndicatorColors(colors);        invalidate();    }    void setDividerColors(int... colors) {        // Make sure that the custom colorizer is removed        customTabColorizer = null;        defaultTabColorizer.setDividerColors(colors);        invalidate();    }    public void onViewPagerPageChanged(int position, float positionOffset) {        this.selectedPosition = position;        this.selectionOffset = positionOffset;        if (positionOffset == 0f && lastPosition != selectedPosition) {            lastPosition = selectedPosition;        }        invalidate();    }    boolean isIndicatorAlwaysInCenter() {        return indicatorAlwaysInCenter;    }    TabColorizer getTabColorizer() {        return (customTabColorizer != null) ? customTabColorizer : defaultTabColorizer;    }    @Override    protected void onDraw(Canvas canvas) {        if (!drawDecorationAfterTab) {            drawDecoration(canvas);        }    }    @Override    protected void dispatchDraw(Canvas canvas) {        super.dispatchDraw(canvas);        if (drawDecorationAfterTab) {            drawDecoration(canvas);        }    }    private void drawDecoration(Canvas canvas) {        final int height = getHeight();        final int width = getWidth();        final int tabCount = getChildCount();        final TabColorizer tabColorizer = getTabColorizer();        final boolean isLayoutRtl = ViewUtil.Companion.getInstance().isLayoutRtl(this);        if (indicatorInFront) {            drawOverline(canvas, 0, width);            drawUnderline(canvas, 0, width, height);        }        // Thick colored underline below the current selection        if (tabCount > 0) {            View selectedTab = getChildAt(selectedPosition);            int selectedStart = ViewUtil.Companion.getInstance().getStart(selectedTab, indicatorWithoutPadding);            int selectedEnd = ViewUtil.Companion.getInstance().getEnd(selectedTab, indicatorWithoutPadding);            int left;            int right;            if (isLayoutRtl) {                left = selectedEnd;                right = selectedStart;            } else {                left = selectedStart;                right = selectedEnd;            }            int color = tabColorizer.getIndicatorColor(selectedPosition);            float thickness = indicatorThickness;            if (selectionOffset > 0f && selectedPosition < (getChildCount() - 1)) {                int nextColor = tabColorizer.getIndicatorColor(selectedPosition + 1);                if (color != nextColor) {                    color = blendColors(nextColor, color, selectionOffset);                }                // Draw the selection partway between the tabs                float startOffset = tabIndicationInterpolator.getLeftEdge(selectionOffset);                float endOffset = tabIndicationInterpolator.getRightEdge(selectionOffset);                float thicknessOffset = tabIndicationInterpolator.getThickness(selectionOffset);                View nextTab = getChildAt(selectedPosition + 1);                int nextStart = ViewUtil.Companion.getInstance().getStart(nextTab, indicatorWithoutPadding);                int nextEnd = ViewUtil.Companion.getInstance().getEnd(nextTab, indicatorWithoutPadding);                if (isLayoutRtl) {                    left = (int) (endOffset * nextEnd + (1.0f - endOffset) * left);                    right = (int) (startOffset * nextStart + (1.0f - startOffset) * right);                } else {                    left = (int) (startOffset * nextStart + (1.0f - startOffset) * left);                    right = (int) (endOffset * nextEnd + (1.0f - endOffset) * right);                }                thickness = thickness * thicknessOffset;            }            drawIndicator(canvas, left, right, height, thickness, color);        }        if (!indicatorInFront) {            drawOverline(canvas, 0, width);            drawUnderline(canvas, 0, getWidth(), height);        }        // Vertical separators between the titles        drawSeparator(canvas, height, tabCount);    }    private void drawSeparator(Canvas canvas, int height, int tabCount) {        if (dividerThickness <= 0) {            return;        }        final int dividerHeightPx = (int) (Math.min(Math.max(0f, dividerHeight), 1f) * height);        final TabColorizer tabColorizer = getTabColorizer();        // Vertical separators between the titles        final int separatorTop = (height - dividerHeightPx) / 2;        final int separatorBottom = separatorTop + dividerHeightPx;        final boolean isLayoutRtl = ViewUtil.Companion.getInstance().isLayoutRtl(this);        for (int i = 0; i < tabCount - 1; i++) {            View child = getChildAt(i);            int end = ViewUtil.Companion.getInstance().getEnd(child);            int endMargin = ViewUtil.Companion.getInstance().getMarginEnd(child);            int separatorX = isLayoutRtl ? end - endMargin : end + endMargin;            dividerPaint.setColor(tabColorizer.getDividerColor(i));            canvas.drawLine(separatorX, separatorTop, separatorX, separatorBottom, dividerPaint);        }    }    private void drawIndicator(Canvas canvas, int left, int right, int height, float thickness, int color) {        if (indicatorThickness <= 0 || indicatorWidth == 0) {            return;        }        float center;        float top;        float bottom;        switch (indicatorGravity) {            case GRAVITY_TOP:                center = indicatorThickness / 2f;                top = center - (thickness / 2f);                bottom = center + (thickness / 2f);                break;            case GRAVITY_CENTER:                center = height / 2f;                top = center - (thickness / 2f);                bottom = center + (thickness / 2f);                break;            case GRAVITY_BOTTOM:            default:                center = height - (indicatorThickness / 2f);                top = center - (thickness / 2f);                bottom = center + (thickness / 2f);                break;        }        indicatorPaint.setColor(color);        if (indicatorWidth == AUTO_WIDTH) {            indicatorRectF.set(left, top, right, bottom);        } else {            float padding = (Math.abs(left - right) - indicatorWidth) / 2f;            indicatorRectF.set(left + padding, top, right - padding, bottom);        }        if (indicatorCornerRadius > 0f) {            canvas.drawRoundRect(indicatorRectF, indicatorCornerRadius, indicatorCornerRadius, indicatorPaint);        } else {            canvas.drawRect(indicatorRectF, indicatorPaint);        }    }    private void drawOverline(Canvas canvas, int left, int right) {        if (topBorderThickness <= 0) {            return;        }        // Thin overline along the entire top edge        borderPaint.setColor(topBorderColor);        canvas.drawRect(left, 0, right, topBorderThickness, borderPaint);    }    private void drawUnderline(Canvas canvas, int left, int right, int height) {        if (bottomBorderThickness <= 0) {            return;        }        // Thin underline along the entire bottom edge        borderPaint.setColor(bottomBorderColor);        canvas.drawRect(left, height - bottomBorderThickness, right, height, borderPaint);    }}